// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: APIPackets.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_APIPackets_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_APIPackets_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_APIPackets_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_APIPackets_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_APIPackets_2eproto;
class AppInfoPacket;
struct AppInfoPacketDefaultTypeInternal;
extern AppInfoPacketDefaultTypeInternal _AppInfoPacket_default_instance_;
class CurrentBigApp;
struct CurrentBigAppDefaultTypeInternal;
extern CurrentBigAppDefaultTypeInternal _CurrentBigApp_default_instance_;
class InitialPacket;
struct InitialPacketDefaultTypeInternal;
extern InitialPacketDefaultTypeInternal _InitialPacket_default_instance_;
class LibraryInfoPacket;
struct LibraryInfoPacketDefaultTypeInternal;
extern LibraryInfoPacketDefaultTypeInternal _LibraryInfoPacket_default_instance_;
class MemoryInfo;
struct MemoryInfoDefaultTypeInternal;
extern MemoryInfoDefaultTypeInternal _MemoryInfo_default_instance_;
class ProcPacket;
struct ProcPacketDefaultTypeInternal;
extern ProcPacketDefaultTypeInternal _ProcPacket_default_instance_;
class RWPacket;
struct RWPacketDefaultTypeInternal;
extern RWPacketDefaultTypeInternal _RWPacket_default_instance_;
class ResultState;
struct ResultStateDefaultTypeInternal;
extern ResultStateDefaultTypeInternal _ResultState_default_instance_;
class SPRXPacket;
struct SPRXPacketDefaultTypeInternal;
extern SPRXPacketDefaultTypeInternal _SPRXPacket_default_instance_;
class TargetInfoPacket;
struct TargetInfoPacketDefaultTypeInternal;
extern TargetInfoPacketDefaultTypeInternal _TargetInfoPacket_default_instance_;
class TargetNotifyPacket;
struct TargetNotifyPacketDefaultTypeInternal;
extern TargetNotifyPacketDefaultTypeInternal _TargetNotifyPacket_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::AppInfoPacket* Arena::CreateMaybeMessage<::AppInfoPacket>(Arena*);
template<> ::CurrentBigApp* Arena::CreateMaybeMessage<::CurrentBigApp>(Arena*);
template<> ::InitialPacket* Arena::CreateMaybeMessage<::InitialPacket>(Arena*);
template<> ::LibraryInfoPacket* Arena::CreateMaybeMessage<::LibraryInfoPacket>(Arena*);
template<> ::MemoryInfo* Arena::CreateMaybeMessage<::MemoryInfo>(Arena*);
template<> ::ProcPacket* Arena::CreateMaybeMessage<::ProcPacket>(Arena*);
template<> ::RWPacket* Arena::CreateMaybeMessage<::RWPacket>(Arena*);
template<> ::ResultState* Arena::CreateMaybeMessage<::ResultState>(Arena*);
template<> ::SPRXPacket* Arena::CreateMaybeMessage<::SPRXPacket>(Arena*);
template<> ::TargetInfoPacket* Arena::CreateMaybeMessage<::TargetInfoPacket>(Arena*);
template<> ::TargetNotifyPacket* Arena::CreateMaybeMessage<::TargetNotifyPacket>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum APICommand : int {
  API_APPS_CHECK_VER = 0,
  API_APPS_GET_DB = 1,
  API_APPS_GET_INFO_STR = 2,
  API_APPS_STATUS = 3,
  API_APPS_START = 4,
  API_APPS_STOP = 5,
  API_APPS_SUSPEND = 6,
  API_APPS_RESUME = 7,
  API_APPS_DELETE = 8,
  API_APPS_SET_VISIBILITY = 9,
  API_APPS_GET_VISIBILITY = 10,
  API_DBG_ATTACH = 11,
  API_DBG_DETACH = 12,
  API_DBG_GET_CURRENT = 13,
  API_DBG_READ = 14,
  API_DBG_WRITE = 15,
  API_DBG_KILL = 16,
  API_DBG_BREAK = 17,
  API_DBG_RESUME = 18,
  API_DBG_SIGNAL = 19,
  API_DBG_STEP = 20,
  API_DBG_STEP_OVER = 21,
  API_DBG_STEP_OUT = 22,
  API_DBG_GET_CALLSTACK = 23,
  API_DBG_GET_REG = 24,
  API_DBG_SET_REG = 25,
  API_DBG_GET_FREG = 26,
  API_DBG_SET_FREG = 27,
  API_DBG_GET_DBGREG = 28,
  API_DBG_SET_DBGREG = 29,
  API_DBG_LOAD_LIBRARY = 30,
  API_DBG_UNLOAD_LIBRARY = 31,
  API_DBG_RELOAD_LIBRARY = 32,
  API_DBG_LIBRARY_LIST = 33,
  API_DBG_THREAD_LIST = 34,
  API_DBG_THREAD_STOP = 35,
  API_DBG_THREAD_RESUME = 36,
  API_DBG_BREAKPOINT_GETFREE = 37,
  API_DBG_BREAKPOINT_SET = 38,
  API_DBG_BREAKPOINT_UPDATE = 39,
  API_DBG_BREAKPOINT_REMOVE = 40,
  API_DBG_BREAKPOINT_GETINFO = 41,
  API_DBG_BREAKPOINT_LIST = 42,
  API_DBG_WATCHPOINT_SET = 43,
  API_DBG_WATCHPOINT_UPDATE = 44,
  API_DBG_WATCHPOINT_REMOVE = 45,
  API_DBG_WATCHPOINT_GETINFO = 46,
  API_DBG_WATCHPOINT_LIST = 47,
  API_KERN_BASE = 48,
  API_KERN_READ = 49,
  API_KERN_WRITE = 50,
  API_TARGET_INFO = 51,
  API_TARGET_RESTMODE = 52,
  API_TARGET_SHUTDOWN = 53,
  API_TARGET_REBOOT = 54,
  API_TARGET_NOTIFY = 55,
  API_TARGET_BUZZER = 56,
  API_TARGET_SET_LED = 57,
  API_TARGET_SET_SETTINGS = 58,
  API_TARGET_GET_PROC_LIST = 59,
  API_TARGET_SEND_FILE = 60,
  APICommand_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  APICommand_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool APICommand_IsValid(int value);
constexpr APICommand APICommand_MIN = API_APPS_CHECK_VER;
constexpr APICommand APICommand_MAX = API_TARGET_SEND_FILE;
constexpr int APICommand_ARRAYSIZE = APICommand_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* APICommand_descriptor();
template<typename T>
inline const std::string& APICommand_Name(T enum_t_value) {
  static_assert(::std::is_same<T, APICommand>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function APICommand_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    APICommand_descriptor(), enum_t_value);
}
inline bool APICommand_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, APICommand* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<APICommand>(
    APICommand_descriptor(), name, value);
}
enum AppState : int {
  STATE_NOT_RUNNING = 0,
  STATE_RUNNING = 1,
  STATE_SUSPENDED = 2,
  AppState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AppState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AppState_IsValid(int value);
constexpr AppState AppState_MIN = STATE_NOT_RUNNING;
constexpr AppState AppState_MAX = STATE_SUSPENDED;
constexpr int AppState_ARRAYSIZE = AppState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AppState_descriptor();
template<typename T>
inline const std::string& AppState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AppState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AppState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AppState_descriptor(), enum_t_value);
}
inline bool AppState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AppState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AppState>(
    AppState_descriptor(), name, value);
}
// ===================================================================

class InitialPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:InitialPacket) */ {
 public:
  inline InitialPacket() : InitialPacket(nullptr) {}
  ~InitialPacket() override;
  explicit constexpr InitialPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InitialPacket(const InitialPacket& from);
  InitialPacket(InitialPacket&& from) noexcept
    : InitialPacket() {
    *this = ::std::move(from);
  }

  inline InitialPacket& operator=(const InitialPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitialPacket& operator=(InitialPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitialPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitialPacket* internal_default_instance() {
    return reinterpret_cast<const InitialPacket*>(
               &_InitialPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(InitialPacket& a, InitialPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(InitialPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitialPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitialPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InitialPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InitialPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InitialPacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitialPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "InitialPacket";
  }
  protected:
  explicit InitialPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPacketVersionFieldNumber = 1,
    kCommandFieldNumber = 2,
  };
  // int32 PacketVersion = 1;
  void clear_packetversion();
  int32_t packetversion() const;
  void set_packetversion(int32_t value);
  private:
  int32_t _internal_packetversion() const;
  void _internal_set_packetversion(int32_t value);
  public:

  // int32 Command = 2;
  void clear_command();
  int32_t command() const;
  void set_command(int32_t value);
  private:
  int32_t _internal_command() const;
  void _internal_set_command(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:InitialPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t packetversion_;
  int32_t command_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class ResultState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ResultState) */ {
 public:
  inline ResultState() : ResultState(nullptr) {}
  ~ResultState() override;
  explicit constexpr ResultState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResultState(const ResultState& from);
  ResultState(ResultState&& from) noexcept
    : ResultState() {
    *this = ::std::move(from);
  }

  inline ResultState& operator=(const ResultState& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResultState& operator=(ResultState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResultState& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResultState* internal_default_instance() {
    return reinterpret_cast<const ResultState*>(
               &_ResultState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ResultState& a, ResultState& b) {
    a.Swap(&b);
  }
  inline void Swap(ResultState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResultState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResultState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResultState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResultState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ResultState& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResultState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ResultState";
  }
  protected:
  explicit ResultState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 2,
    kSucceededFieldNumber = 1,
  };
  // string ErrorMessage = 2;
  void clear_errormessage();
  const std::string& errormessage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_errormessage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_errormessage();
  PROTOBUF_NODISCARD std::string* release_errormessage();
  void set_allocated_errormessage(std::string* errormessage);
  private:
  const std::string& _internal_errormessage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_errormessage(const std::string& value);
  std::string* _internal_mutable_errormessage();
  public:

  // bool Succeeded = 1;
  void clear_succeeded();
  bool succeeded() const;
  void set_succeeded(bool value);
  private:
  bool _internal_succeeded() const;
  void _internal_set_succeeded(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ResultState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr errormessage_;
  bool succeeded_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class AppInfoPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AppInfoPacket) */ {
 public:
  inline AppInfoPacket() : AppInfoPacket(nullptr) {}
  ~AppInfoPacket() override;
  explicit constexpr AppInfoPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppInfoPacket(const AppInfoPacket& from);
  AppInfoPacket(AppInfoPacket&& from) noexcept
    : AppInfoPacket() {
    *this = ::std::move(from);
  }

  inline AppInfoPacket& operator=(const AppInfoPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppInfoPacket& operator=(AppInfoPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppInfoPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppInfoPacket* internal_default_instance() {
    return reinterpret_cast<const AppInfoPacket*>(
               &_AppInfoPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AppInfoPacket& a, AppInfoPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(AppInfoPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppInfoPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppInfoPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppInfoPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppInfoPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppInfoPacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppInfoPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AppInfoPacket";
  }
  protected:
  explicit AppInfoPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleIdFieldNumber = 1,
    kContentIdFieldNumber = 2,
    kTitleNameFieldNumber = 3,
    kMetaDataPathFieldNumber = 4,
    kLastAccessTimeFieldNumber = 5,
    kCategoryFieldNumber = 9,
    kInstallDateFieldNumber = 11,
    kUICategoryFieldNumber = 12,
    kIsVisibleFieldNumber = 6,
    kSortPriorityFieldNumber = 7,
    kDispLocationFieldNumber = 8,
    kContentSizeFieldNumber = 10,
  };
  // string TitleId = 1;
  void clear_titleid();
  const std::string& titleid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_titleid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_titleid();
  PROTOBUF_NODISCARD std::string* release_titleid();
  void set_allocated_titleid(std::string* titleid);
  private:
  const std::string& _internal_titleid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_titleid(const std::string& value);
  std::string* _internal_mutable_titleid();
  public:

  // string ContentId = 2;
  void clear_contentid();
  const std::string& contentid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contentid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contentid();
  PROTOBUF_NODISCARD std::string* release_contentid();
  void set_allocated_contentid(std::string* contentid);
  private:
  const std::string& _internal_contentid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contentid(const std::string& value);
  std::string* _internal_mutable_contentid();
  public:

  // string TitleName = 3;
  void clear_titlename();
  const std::string& titlename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_titlename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_titlename();
  PROTOBUF_NODISCARD std::string* release_titlename();
  void set_allocated_titlename(std::string* titlename);
  private:
  const std::string& _internal_titlename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_titlename(const std::string& value);
  std::string* _internal_mutable_titlename();
  public:

  // string MetaDataPath = 4;
  void clear_metadatapath();
  const std::string& metadatapath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_metadatapath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_metadatapath();
  PROTOBUF_NODISCARD std::string* release_metadatapath();
  void set_allocated_metadatapath(std::string* metadatapath);
  private:
  const std::string& _internal_metadatapath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_metadatapath(const std::string& value);
  std::string* _internal_mutable_metadatapath();
  public:

  // string LastAccessTime = 5;
  void clear_lastaccesstime();
  const std::string& lastaccesstime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lastaccesstime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lastaccesstime();
  PROTOBUF_NODISCARD std::string* release_lastaccesstime();
  void set_allocated_lastaccesstime(std::string* lastaccesstime);
  private:
  const std::string& _internal_lastaccesstime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lastaccesstime(const std::string& value);
  std::string* _internal_mutable_lastaccesstime();
  public:

  // string Category = 9;
  void clear_category();
  const std::string& category() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_category(ArgT0&& arg0, ArgT... args);
  std::string* mutable_category();
  PROTOBUF_NODISCARD std::string* release_category();
  void set_allocated_category(std::string* category);
  private:
  const std::string& _internal_category() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
  std::string* _internal_mutable_category();
  public:

  // string InstallDate = 11;
  void clear_installdate();
  const std::string& installdate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_installdate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_installdate();
  PROTOBUF_NODISCARD std::string* release_installdate();
  void set_allocated_installdate(std::string* installdate);
  private:
  const std::string& _internal_installdate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_installdate(const std::string& value);
  std::string* _internal_mutable_installdate();
  public:

  // string UICategory = 12;
  void clear_uicategory();
  const std::string& uicategory() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uicategory(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uicategory();
  PROTOBUF_NODISCARD std::string* release_uicategory();
  void set_allocated_uicategory(std::string* uicategory);
  private:
  const std::string& _internal_uicategory() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uicategory(const std::string& value);
  std::string* _internal_mutable_uicategory();
  public:

  // bool IsVisible = 6;
  void clear_isvisible();
  bool isvisible() const;
  void set_isvisible(bool value);
  private:
  bool _internal_isvisible() const;
  void _internal_set_isvisible(bool value);
  public:

  // int32 SortPriority = 7;
  void clear_sortpriority();
  int32_t sortpriority() const;
  void set_sortpriority(int32_t value);
  private:
  int32_t _internal_sortpriority() const;
  void _internal_set_sortpriority(int32_t value);
  public:

  // int32 DispLocation = 8;
  void clear_displocation();
  int32_t displocation() const;
  void set_displocation(int32_t value);
  private:
  int32_t _internal_displocation() const;
  void _internal_set_displocation(int32_t value);
  public:

  // int32 ContentSize = 10;
  void clear_contentsize();
  int32_t contentsize() const;
  void set_contentsize(int32_t value);
  private:
  int32_t _internal_contentsize() const;
  void _internal_set_contentsize(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:AppInfoPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr titleid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contentid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr titlename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr metadatapath_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lastaccesstime_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr installdate_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uicategory_;
  bool isvisible_;
  int32_t sortpriority_;
  int32_t displocation_;
  int32_t contentsize_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class RWPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RWPacket) */ {
 public:
  inline RWPacket() : RWPacket(nullptr) {}
  ~RWPacket() override;
  explicit constexpr RWPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RWPacket(const RWPacket& from);
  RWPacket(RWPacket&& from) noexcept
    : RWPacket() {
    *this = ::std::move(from);
  }

  inline RWPacket& operator=(const RWPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline RWPacket& operator=(RWPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RWPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const RWPacket* internal_default_instance() {
    return reinterpret_cast<const RWPacket*>(
               &_RWPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RWPacket& a, RWPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(RWPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RWPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RWPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RWPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RWPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RWPacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RWPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RWPacket";
  }
  protected:
  explicit RWPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kLengthFieldNumber = 2,
  };
  // uint64 Address = 1;
  void clear_address();
  uint64_t address() const;
  void set_address(uint64_t value);
  private:
  uint64_t _internal_address() const;
  void _internal_set_address(uint64_t value);
  public:

  // uint64 Length = 2;
  void clear_length();
  uint64_t length() const;
  void set_length(uint64_t value);
  private:
  uint64_t _internal_length() const;
  void _internal_set_length(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:RWPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t address_;
  uint64_t length_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class SPRXPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SPRXPacket) */ {
 public:
  inline SPRXPacket() : SPRXPacket(nullptr) {}
  ~SPRXPacket() override;
  explicit constexpr SPRXPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SPRXPacket(const SPRXPacket& from);
  SPRXPacket(SPRXPacket&& from) noexcept
    : SPRXPacket() {
    *this = ::std::move(from);
  }

  inline SPRXPacket& operator=(const SPRXPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline SPRXPacket& operator=(SPRXPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SPRXPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const SPRXPacket* internal_default_instance() {
    return reinterpret_cast<const SPRXPacket*>(
               &_SPRXPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SPRXPacket& a, SPRXPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(SPRXPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SPRXPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SPRXPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SPRXPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SPRXPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SPRXPacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SPRXPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SPRXPacket";
  }
  protected:
  explicit SPRXPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kHandleFieldNumber = 2,
  };
  // string Path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // int32 Handle = 2;
  void clear_handle();
  int32_t handle() const;
  void set_handle(int32_t value);
  private:
  int32_t _internal_handle() const;
  void _internal_set_handle(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:SPRXPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  int32_t handle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class MemoryInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MemoryInfo) */ {
 public:
  inline MemoryInfo() : MemoryInfo(nullptr) {}
  ~MemoryInfo() override;
  explicit constexpr MemoryInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MemoryInfo(const MemoryInfo& from);
  MemoryInfo(MemoryInfo&& from) noexcept
    : MemoryInfo() {
    *this = ::std::move(from);
  }

  inline MemoryInfo& operator=(const MemoryInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MemoryInfo& operator=(MemoryInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MemoryInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MemoryInfo* internal_default_instance() {
    return reinterpret_cast<const MemoryInfo*>(
               &_MemoryInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MemoryInfo& a, MemoryInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(MemoryInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MemoryInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MemoryInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MemoryInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MemoryInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MemoryInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MemoryInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MemoryInfo";
  }
  protected:
  explicit MemoryInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsedFieldNumber = 1,
    kFreeFieldNumber = 2,
    kTotalFieldNumber = 3,
    kPercentageFieldNumber = 4,
  };
  // int32 Used = 1;
  void clear_used();
  int32_t used() const;
  void set_used(int32_t value);
  private:
  int32_t _internal_used() const;
  void _internal_set_used(int32_t value);
  public:

  // int32 Free = 2;
  void clear_free();
  int32_t free() const;
  void set_free(int32_t value);
  private:
  int32_t _internal_free() const;
  void _internal_set_free(int32_t value);
  public:

  // int32 Total = 3;
  void clear_total();
  int32_t total() const;
  void set_total(int32_t value);
  private:
  int32_t _internal_total() const;
  void _internal_set_total(int32_t value);
  public:

  // float Percentage = 4;
  void clear_percentage();
  float percentage() const;
  void set_percentage(float value);
  private:
  float _internal_percentage() const;
  void _internal_set_percentage(float value);
  public:

  // @@protoc_insertion_point(class_scope:MemoryInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t used_;
  int32_t free_;
  int32_t total_;
  float percentage_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class CurrentBigApp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CurrentBigApp) */ {
 public:
  inline CurrentBigApp() : CurrentBigApp(nullptr) {}
  ~CurrentBigApp() override;
  explicit constexpr CurrentBigApp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CurrentBigApp(const CurrentBigApp& from);
  CurrentBigApp(CurrentBigApp&& from) noexcept
    : CurrentBigApp() {
    *this = ::std::move(from);
  }

  inline CurrentBigApp& operator=(const CurrentBigApp& from) {
    CopyFrom(from);
    return *this;
  }
  inline CurrentBigApp& operator=(CurrentBigApp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CurrentBigApp& default_instance() {
    return *internal_default_instance();
  }
  static inline const CurrentBigApp* internal_default_instance() {
    return reinterpret_cast<const CurrentBigApp*>(
               &_CurrentBigApp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CurrentBigApp& a, CurrentBigApp& b) {
    a.Swap(&b);
  }
  inline void Swap(CurrentBigApp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CurrentBigApp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CurrentBigApp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CurrentBigApp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CurrentBigApp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CurrentBigApp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CurrentBigApp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CurrentBigApp";
  }
  protected:
  explicit CurrentBigApp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kTitleIdFieldNumber = 3,
    kPidFieldNumber = 1,
  };
  // string Name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string TitleId = 3;
  void clear_titleid();
  const std::string& titleid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_titleid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_titleid();
  PROTOBUF_NODISCARD std::string* release_titleid();
  void set_allocated_titleid(std::string* titleid);
  private:
  const std::string& _internal_titleid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_titleid(const std::string& value);
  std::string* _internal_mutable_titleid();
  public:

  // int32 Pid = 1;
  void clear_pid();
  int32_t pid() const;
  void set_pid(int32_t value);
  private:
  int32_t _internal_pid() const;
  void _internal_set_pid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CurrentBigApp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr titleid_;
  int32_t pid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class TargetInfoPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TargetInfoPacket) */ {
 public:
  inline TargetInfoPacket() : TargetInfoPacket(nullptr) {}
  ~TargetInfoPacket() override;
  explicit constexpr TargetInfoPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TargetInfoPacket(const TargetInfoPacket& from);
  TargetInfoPacket(TargetInfoPacket&& from) noexcept
    : TargetInfoPacket() {
    *this = ::std::move(from);
  }

  inline TargetInfoPacket& operator=(const TargetInfoPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline TargetInfoPacket& operator=(TargetInfoPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TargetInfoPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const TargetInfoPacket* internal_default_instance() {
    return reinterpret_cast<const TargetInfoPacket*>(
               &_TargetInfoPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TargetInfoPacket& a, TargetInfoPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(TargetInfoPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TargetInfoPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TargetInfoPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TargetInfoPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TargetInfoPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TargetInfoPacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TargetInfoPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TargetInfoPacket";
  }
  protected:
  explicit TargetInfoPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConsoleNameFieldNumber = 5,
    kMotherboardSerialFieldNumber = 6,
    kSerialFieldNumber = 7,
    kModelFieldNumber = 8,
    kMACAdressLANFieldNumber = 9,
    kMACAdressWIFIFieldNumber = 10,
    kIDPSFieldNumber = 13,
    kPSIDFieldNumber = 14,
    kBigAppFieldNumber = 4,
    kRamFieldNumber = 26,
    kVRamFieldNumber = 27,
    kSDKVersionFieldNumber = 1,
    kSoftwareVersionFieldNumber = 2,
    kFactorySoftwareVersionFieldNumber = 3,
    kUARTFieldNumber = 11,
    kIDUModeFieldNumber = 12,
    kConsoleTypeFieldNumber = 15,
    kAttachedFieldNumber = 16,
    kAttachedPidFieldNumber = 17,
    kForegroundAccountIdFieldNumber = 18,
    kFreeSpaceFieldNumber = 19,
    kTotalSpaceFieldNumber = 20,
    kCPUTempFieldNumber = 21,
    kSOCTempFieldNumber = 22,
    kThreadCountFieldNumber = 23,
    kAverageCPUUsageFieldNumber = 24,
    kBusyCoreFieldNumber = 25,
  };
  // string ConsoleName = 5;
  void clear_consolename();
  const std::string& consolename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_consolename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_consolename();
  PROTOBUF_NODISCARD std::string* release_consolename();
  void set_allocated_consolename(std::string* consolename);
  private:
  const std::string& _internal_consolename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_consolename(const std::string& value);
  std::string* _internal_mutable_consolename();
  public:

  // string MotherboardSerial = 6;
  void clear_motherboardserial();
  const std::string& motherboardserial() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_motherboardserial(ArgT0&& arg0, ArgT... args);
  std::string* mutable_motherboardserial();
  PROTOBUF_NODISCARD std::string* release_motherboardserial();
  void set_allocated_motherboardserial(std::string* motherboardserial);
  private:
  const std::string& _internal_motherboardserial() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_motherboardserial(const std::string& value);
  std::string* _internal_mutable_motherboardserial();
  public:

  // string Serial = 7;
  void clear_serial();
  const std::string& serial() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serial(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serial();
  PROTOBUF_NODISCARD std::string* release_serial();
  void set_allocated_serial(std::string* serial);
  private:
  const std::string& _internal_serial() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serial(const std::string& value);
  std::string* _internal_mutable_serial();
  public:

  // string Model = 8;
  void clear_model();
  const std::string& model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model();
  PROTOBUF_NODISCARD std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // string MACAdressLAN = 9;
  void clear_macadresslan();
  const std::string& macadresslan() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_macadresslan(ArgT0&& arg0, ArgT... args);
  std::string* mutable_macadresslan();
  PROTOBUF_NODISCARD std::string* release_macadresslan();
  void set_allocated_macadresslan(std::string* macadresslan);
  private:
  const std::string& _internal_macadresslan() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_macadresslan(const std::string& value);
  std::string* _internal_mutable_macadresslan();
  public:

  // string MACAdressWIFI = 10;
  void clear_macadresswifi();
  const std::string& macadresswifi() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_macadresswifi(ArgT0&& arg0, ArgT... args);
  std::string* mutable_macadresswifi();
  PROTOBUF_NODISCARD std::string* release_macadresswifi();
  void set_allocated_macadresswifi(std::string* macadresswifi);
  private:
  const std::string& _internal_macadresswifi() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_macadresswifi(const std::string& value);
  std::string* _internal_mutable_macadresswifi();
  public:

  // string IDPS = 13;
  void clear_idps();
  const std::string& idps() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_idps(ArgT0&& arg0, ArgT... args);
  std::string* mutable_idps();
  PROTOBUF_NODISCARD std::string* release_idps();
  void set_allocated_idps(std::string* idps);
  private:
  const std::string& _internal_idps() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_idps(const std::string& value);
  std::string* _internal_mutable_idps();
  public:

  // string PSID = 14;
  void clear_psid();
  const std::string& psid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_psid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_psid();
  PROTOBUF_NODISCARD std::string* release_psid();
  void set_allocated_psid(std::string* psid);
  private:
  const std::string& _internal_psid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_psid(const std::string& value);
  std::string* _internal_mutable_psid();
  public:

  // .CurrentBigApp BigApp = 4;
  bool has_bigapp() const;
  private:
  bool _internal_has_bigapp() const;
  public:
  void clear_bigapp();
  const ::CurrentBigApp& bigapp() const;
  PROTOBUF_NODISCARD ::CurrentBigApp* release_bigapp();
  ::CurrentBigApp* mutable_bigapp();
  void set_allocated_bigapp(::CurrentBigApp* bigapp);
  private:
  const ::CurrentBigApp& _internal_bigapp() const;
  ::CurrentBigApp* _internal_mutable_bigapp();
  public:
  void unsafe_arena_set_allocated_bigapp(
      ::CurrentBigApp* bigapp);
  ::CurrentBigApp* unsafe_arena_release_bigapp();

  // .MemoryInfo Ram = 26;
  bool has_ram() const;
  private:
  bool _internal_has_ram() const;
  public:
  void clear_ram();
  const ::MemoryInfo& ram() const;
  PROTOBUF_NODISCARD ::MemoryInfo* release_ram();
  ::MemoryInfo* mutable_ram();
  void set_allocated_ram(::MemoryInfo* ram);
  private:
  const ::MemoryInfo& _internal_ram() const;
  ::MemoryInfo* _internal_mutable_ram();
  public:
  void unsafe_arena_set_allocated_ram(
      ::MemoryInfo* ram);
  ::MemoryInfo* unsafe_arena_release_ram();

  // .MemoryInfo VRam = 27;
  bool has_vram() const;
  private:
  bool _internal_has_vram() const;
  public:
  void clear_vram();
  const ::MemoryInfo& vram() const;
  PROTOBUF_NODISCARD ::MemoryInfo* release_vram();
  ::MemoryInfo* mutable_vram();
  void set_allocated_vram(::MemoryInfo* vram);
  private:
  const ::MemoryInfo& _internal_vram() const;
  ::MemoryInfo* _internal_mutable_vram();
  public:
  void unsafe_arena_set_allocated_vram(
      ::MemoryInfo* vram);
  ::MemoryInfo* unsafe_arena_release_vram();

  // int32 SDKVersion = 1;
  void clear_sdkversion();
  int32_t sdkversion() const;
  void set_sdkversion(int32_t value);
  private:
  int32_t _internal_sdkversion() const;
  void _internal_set_sdkversion(int32_t value);
  public:

  // int32 SoftwareVersion = 2;
  void clear_softwareversion();
  int32_t softwareversion() const;
  void set_softwareversion(int32_t value);
  private:
  int32_t _internal_softwareversion() const;
  void _internal_set_softwareversion(int32_t value);
  public:

  // int32 FactorySoftwareVersion = 3;
  void clear_factorysoftwareversion();
  int32_t factorysoftwareversion() const;
  void set_factorysoftwareversion(int32_t value);
  private:
  int32_t _internal_factorysoftwareversion() const;
  void _internal_set_factorysoftwareversion(int32_t value);
  public:

  // bool UART = 11;
  void clear_uart();
  bool uart() const;
  void set_uart(bool value);
  private:
  bool _internal_uart() const;
  void _internal_set_uart(bool value);
  public:

  // bool IDUMode = 12;
  void clear_idumode();
  bool idumode() const;
  void set_idumode(bool value);
  private:
  bool _internal_idumode() const;
  void _internal_set_idumode(bool value);
  public:

  // int32 ConsoleType = 15;
  void clear_consoletype();
  int32_t consoletype() const;
  void set_consoletype(int32_t value);
  private:
  int32_t _internal_consoletype() const;
  void _internal_set_consoletype(int32_t value);
  public:

  // int32 Attached = 16;
  void clear_attached();
  int32_t attached() const;
  void set_attached(int32_t value);
  private:
  int32_t _internal_attached() const;
  void _internal_set_attached(int32_t value);
  public:

  // int32 AttachedPid = 17;
  void clear_attachedpid();
  int32_t attachedpid() const;
  void set_attachedpid(int32_t value);
  private:
  int32_t _internal_attachedpid() const;
  void _internal_set_attachedpid(int32_t value);
  public:

  // int32 ForegroundAccountId = 18;
  void clear_foregroundaccountid();
  int32_t foregroundaccountid() const;
  void set_foregroundaccountid(int32_t value);
  private:
  int32_t _internal_foregroundaccountid() const;
  void _internal_set_foregroundaccountid(int32_t value);
  public:

  // uint64 FreeSpace = 19;
  void clear_freespace();
  uint64_t freespace() const;
  void set_freespace(uint64_t value);
  private:
  uint64_t _internal_freespace() const;
  void _internal_set_freespace(uint64_t value);
  public:

  // uint64 TotalSpace = 20;
  void clear_totalspace();
  uint64_t totalspace() const;
  void set_totalspace(uint64_t value);
  private:
  uint64_t _internal_totalspace() const;
  void _internal_set_totalspace(uint64_t value);
  public:

  // int32 CPUTemp = 21;
  void clear_cputemp();
  int32_t cputemp() const;
  void set_cputemp(int32_t value);
  private:
  int32_t _internal_cputemp() const;
  void _internal_set_cputemp(int32_t value);
  public:

  // int32 SOCTemp = 22;
  void clear_soctemp();
  int32_t soctemp() const;
  void set_soctemp(int32_t value);
  private:
  int32_t _internal_soctemp() const;
  void _internal_set_soctemp(int32_t value);
  public:

  // int32 ThreadCount = 23;
  void clear_threadcount();
  int32_t threadcount() const;
  void set_threadcount(int32_t value);
  private:
  int32_t _internal_threadcount() const;
  void _internal_set_threadcount(int32_t value);
  public:

  // float AverageCPUUsage = 24;
  void clear_averagecpuusage();
  float averagecpuusage() const;
  void set_averagecpuusage(float value);
  private:
  float _internal_averagecpuusage() const;
  void _internal_set_averagecpuusage(float value);
  public:

  // int32 BusyCore = 25;
  void clear_busycore();
  int32_t busycore() const;
  void set_busycore(int32_t value);
  private:
  int32_t _internal_busycore() const;
  void _internal_set_busycore(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TargetInfoPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr consolename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr motherboardserial_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr macadresslan_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr macadresswifi_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr idps_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr psid_;
  ::CurrentBigApp* bigapp_;
  ::MemoryInfo* ram_;
  ::MemoryInfo* vram_;
  int32_t sdkversion_;
  int32_t softwareversion_;
  int32_t factorysoftwareversion_;
  bool uart_;
  bool idumode_;
  int32_t consoletype_;
  int32_t attached_;
  int32_t attachedpid_;
  int32_t foregroundaccountid_;
  uint64_t freespace_;
  uint64_t totalspace_;
  int32_t cputemp_;
  int32_t soctemp_;
  int32_t threadcount_;
  float averagecpuusage_;
  int32_t busycore_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class TargetNotifyPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TargetNotifyPacket) */ {
 public:
  inline TargetNotifyPacket() : TargetNotifyPacket(nullptr) {}
  ~TargetNotifyPacket() override;
  explicit constexpr TargetNotifyPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TargetNotifyPacket(const TargetNotifyPacket& from);
  TargetNotifyPacket(TargetNotifyPacket&& from) noexcept
    : TargetNotifyPacket() {
    *this = ::std::move(from);
  }

  inline TargetNotifyPacket& operator=(const TargetNotifyPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline TargetNotifyPacket& operator=(TargetNotifyPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TargetNotifyPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const TargetNotifyPacket* internal_default_instance() {
    return reinterpret_cast<const TargetNotifyPacket*>(
               &_TargetNotifyPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TargetNotifyPacket& a, TargetNotifyPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(TargetNotifyPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TargetNotifyPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TargetNotifyPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TargetNotifyPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TargetNotifyPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TargetNotifyPacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TargetNotifyPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TargetNotifyPacket";
  }
  protected:
  explicit TargetNotifyPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIconURIFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // string IconURI = 1;
  void clear_iconuri();
  const std::string& iconuri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_iconuri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_iconuri();
  PROTOBUF_NODISCARD std::string* release_iconuri();
  void set_allocated_iconuri(std::string* iconuri);
  private:
  const std::string& _internal_iconuri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_iconuri(const std::string& value);
  std::string* _internal_mutable_iconuri();
  public:

  // string Message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:TargetNotifyPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr iconuri_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class ProcPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ProcPacket) */ {
 public:
  inline ProcPacket() : ProcPacket(nullptr) {}
  ~ProcPacket() override;
  explicit constexpr ProcPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProcPacket(const ProcPacket& from);
  ProcPacket(ProcPacket&& from) noexcept
    : ProcPacket() {
    *this = ::std::move(from);
  }

  inline ProcPacket& operator=(const ProcPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcPacket& operator=(ProcPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProcPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProcPacket* internal_default_instance() {
    return reinterpret_cast<const ProcPacket*>(
               &_ProcPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ProcPacket& a, ProcPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProcPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProcPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProcPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProcPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ProcPacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ProcPacket";
  }
  protected:
  explicit ProcPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 3,
    kTitleIdFieldNumber = 4,
    kAppIdFieldNumber = 1,
    kProcessIdFieldNumber = 2,
  };
  // string Name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string TitleId = 4;
  void clear_titleid();
  const std::string& titleid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_titleid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_titleid();
  PROTOBUF_NODISCARD std::string* release_titleid();
  void set_allocated_titleid(std::string* titleid);
  private:
  const std::string& _internal_titleid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_titleid(const std::string& value);
  std::string* _internal_mutable_titleid();
  public:

  // int32 AppId = 1;
  void clear_appid();
  int32_t appid() const;
  void set_appid(int32_t value);
  private:
  int32_t _internal_appid() const;
  void _internal_set_appid(int32_t value);
  public:

  // int32 ProcessId = 2;
  void clear_processid();
  int32_t processid() const;
  void set_processid(int32_t value);
  private:
  int32_t _internal_processid() const;
  void _internal_set_processid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ProcPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr titleid_;
  int32_t appid_;
  int32_t processid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// -------------------------------------------------------------------

class LibraryInfoPacket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LibraryInfoPacket) */ {
 public:
  inline LibraryInfoPacket() : LibraryInfoPacket(nullptr) {}
  ~LibraryInfoPacket() override;
  explicit constexpr LibraryInfoPacket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LibraryInfoPacket(const LibraryInfoPacket& from);
  LibraryInfoPacket(LibraryInfoPacket&& from) noexcept
    : LibraryInfoPacket() {
    *this = ::std::move(from);
  }

  inline LibraryInfoPacket& operator=(const LibraryInfoPacket& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibraryInfoPacket& operator=(LibraryInfoPacket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LibraryInfoPacket& default_instance() {
    return *internal_default_instance();
  }
  static inline const LibraryInfoPacket* internal_default_instance() {
    return reinterpret_cast<const LibraryInfoPacket*>(
               &_LibraryInfoPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(LibraryInfoPacket& a, LibraryInfoPacket& b) {
    a.Swap(&b);
  }
  inline void Swap(LibraryInfoPacket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LibraryInfoPacket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LibraryInfoPacket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LibraryInfoPacket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LibraryInfoPacket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LibraryInfoPacket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibraryInfoPacket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LibraryInfoPacket";
  }
  protected:
  explicit LibraryInfoPacket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 2,
    kMapBaseFieldNumber = 3,
    kMapSizeFieldNumber = 4,
    kTextSizeFieldNumber = 5,
    kDataBaseFieldNumber = 6,
    kDataSizeFieldNumber = 7,
    kHandleFieldNumber = 1,
  };
  // string Path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // uint64 MapBase = 3;
  void clear_mapbase();
  uint64_t mapbase() const;
  void set_mapbase(uint64_t value);
  private:
  uint64_t _internal_mapbase() const;
  void _internal_set_mapbase(uint64_t value);
  public:

  // uint64 MapSize = 4;
  void clear_mapsize();
  uint64_t mapsize() const;
  void set_mapsize(uint64_t value);
  private:
  uint64_t _internal_mapsize() const;
  void _internal_set_mapsize(uint64_t value);
  public:

  // uint64 TextSize = 5;
  void clear_textsize();
  uint64_t textsize() const;
  void set_textsize(uint64_t value);
  private:
  uint64_t _internal_textsize() const;
  void _internal_set_textsize(uint64_t value);
  public:

  // uint64 DataBase = 6;
  void clear_database();
  uint64_t database() const;
  void set_database(uint64_t value);
  private:
  uint64_t _internal_database() const;
  void _internal_set_database(uint64_t value);
  public:

  // uint64 DataSize = 7;
  void clear_datasize();
  uint64_t datasize() const;
  void set_datasize(uint64_t value);
  private:
  uint64_t _internal_datasize() const;
  void _internal_set_datasize(uint64_t value);
  public:

  // uint32 Handle = 1;
  void clear_handle();
  uint32_t handle() const;
  void set_handle(uint32_t value);
  private:
  uint32_t _internal_handle() const;
  void _internal_set_handle(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:LibraryInfoPacket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  uint64_t mapbase_;
  uint64_t mapsize_;
  uint64_t textsize_;
  uint64_t database_;
  uint64_t datasize_;
  uint32_t handle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_APIPackets_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// InitialPacket

// int32 PacketVersion = 1;
inline void InitialPacket::clear_packetversion() {
  packetversion_ = 0;
}
inline int32_t InitialPacket::_internal_packetversion() const {
  return packetversion_;
}
inline int32_t InitialPacket::packetversion() const {
  // @@protoc_insertion_point(field_get:InitialPacket.PacketVersion)
  return _internal_packetversion();
}
inline void InitialPacket::_internal_set_packetversion(int32_t value) {
  
  packetversion_ = value;
}
inline void InitialPacket::set_packetversion(int32_t value) {
  _internal_set_packetversion(value);
  // @@protoc_insertion_point(field_set:InitialPacket.PacketVersion)
}

// int32 Command = 2;
inline void InitialPacket::clear_command() {
  command_ = 0;
}
inline int32_t InitialPacket::_internal_command() const {
  return command_;
}
inline int32_t InitialPacket::command() const {
  // @@protoc_insertion_point(field_get:InitialPacket.Command)
  return _internal_command();
}
inline void InitialPacket::_internal_set_command(int32_t value) {
  
  command_ = value;
}
inline void InitialPacket::set_command(int32_t value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:InitialPacket.Command)
}

// -------------------------------------------------------------------

// ResultState

// bool Succeeded = 1;
inline void ResultState::clear_succeeded() {
  succeeded_ = false;
}
inline bool ResultState::_internal_succeeded() const {
  return succeeded_;
}
inline bool ResultState::succeeded() const {
  // @@protoc_insertion_point(field_get:ResultState.Succeeded)
  return _internal_succeeded();
}
inline void ResultState::_internal_set_succeeded(bool value) {
  
  succeeded_ = value;
}
inline void ResultState::set_succeeded(bool value) {
  _internal_set_succeeded(value);
  // @@protoc_insertion_point(field_set:ResultState.Succeeded)
}

// string ErrorMessage = 2;
inline void ResultState::clear_errormessage() {
  errormessage_.ClearToEmpty();
}
inline const std::string& ResultState::errormessage() const {
  // @@protoc_insertion_point(field_get:ResultState.ErrorMessage)
  return _internal_errormessage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ResultState::set_errormessage(ArgT0&& arg0, ArgT... args) {
 
 errormessage_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ResultState.ErrorMessage)
}
inline std::string* ResultState::mutable_errormessage() {
  std::string* _s = _internal_mutable_errormessage();
  // @@protoc_insertion_point(field_mutable:ResultState.ErrorMessage)
  return _s;
}
inline const std::string& ResultState::_internal_errormessage() const {
  return errormessage_.Get();
}
inline void ResultState::_internal_set_errormessage(const std::string& value) {
  
  errormessage_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ResultState::_internal_mutable_errormessage() {
  
  return errormessage_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ResultState::release_errormessage() {
  // @@protoc_insertion_point(field_release:ResultState.ErrorMessage)
  return errormessage_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ResultState::set_allocated_errormessage(std::string* errormessage) {
  if (errormessage != nullptr) {
    
  } else {
    
  }
  errormessage_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), errormessage,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (errormessage_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    errormessage_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ResultState.ErrorMessage)
}

// -------------------------------------------------------------------

// AppInfoPacket

// string TitleId = 1;
inline void AppInfoPacket::clear_titleid() {
  titleid_.ClearToEmpty();
}
inline const std::string& AppInfoPacket::titleid() const {
  // @@protoc_insertion_point(field_get:AppInfoPacket.TitleId)
  return _internal_titleid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppInfoPacket::set_titleid(ArgT0&& arg0, ArgT... args) {
 
 titleid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AppInfoPacket.TitleId)
}
inline std::string* AppInfoPacket::mutable_titleid() {
  std::string* _s = _internal_mutable_titleid();
  // @@protoc_insertion_point(field_mutable:AppInfoPacket.TitleId)
  return _s;
}
inline const std::string& AppInfoPacket::_internal_titleid() const {
  return titleid_.Get();
}
inline void AppInfoPacket::_internal_set_titleid(const std::string& value) {
  
  titleid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AppInfoPacket::_internal_mutable_titleid() {
  
  return titleid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppInfoPacket::release_titleid() {
  // @@protoc_insertion_point(field_release:AppInfoPacket.TitleId)
  return titleid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppInfoPacket::set_allocated_titleid(std::string* titleid) {
  if (titleid != nullptr) {
    
  } else {
    
  }
  titleid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), titleid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (titleid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    titleid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AppInfoPacket.TitleId)
}

// string ContentId = 2;
inline void AppInfoPacket::clear_contentid() {
  contentid_.ClearToEmpty();
}
inline const std::string& AppInfoPacket::contentid() const {
  // @@protoc_insertion_point(field_get:AppInfoPacket.ContentId)
  return _internal_contentid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppInfoPacket::set_contentid(ArgT0&& arg0, ArgT... args) {
 
 contentid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AppInfoPacket.ContentId)
}
inline std::string* AppInfoPacket::mutable_contentid() {
  std::string* _s = _internal_mutable_contentid();
  // @@protoc_insertion_point(field_mutable:AppInfoPacket.ContentId)
  return _s;
}
inline const std::string& AppInfoPacket::_internal_contentid() const {
  return contentid_.Get();
}
inline void AppInfoPacket::_internal_set_contentid(const std::string& value) {
  
  contentid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AppInfoPacket::_internal_mutable_contentid() {
  
  return contentid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppInfoPacket::release_contentid() {
  // @@protoc_insertion_point(field_release:AppInfoPacket.ContentId)
  return contentid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppInfoPacket::set_allocated_contentid(std::string* contentid) {
  if (contentid != nullptr) {
    
  } else {
    
  }
  contentid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), contentid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contentid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    contentid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AppInfoPacket.ContentId)
}

// string TitleName = 3;
inline void AppInfoPacket::clear_titlename() {
  titlename_.ClearToEmpty();
}
inline const std::string& AppInfoPacket::titlename() const {
  // @@protoc_insertion_point(field_get:AppInfoPacket.TitleName)
  return _internal_titlename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppInfoPacket::set_titlename(ArgT0&& arg0, ArgT... args) {
 
 titlename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AppInfoPacket.TitleName)
}
inline std::string* AppInfoPacket::mutable_titlename() {
  std::string* _s = _internal_mutable_titlename();
  // @@protoc_insertion_point(field_mutable:AppInfoPacket.TitleName)
  return _s;
}
inline const std::string& AppInfoPacket::_internal_titlename() const {
  return titlename_.Get();
}
inline void AppInfoPacket::_internal_set_titlename(const std::string& value) {
  
  titlename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AppInfoPacket::_internal_mutable_titlename() {
  
  return titlename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppInfoPacket::release_titlename() {
  // @@protoc_insertion_point(field_release:AppInfoPacket.TitleName)
  return titlename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppInfoPacket::set_allocated_titlename(std::string* titlename) {
  if (titlename != nullptr) {
    
  } else {
    
  }
  titlename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), titlename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (titlename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    titlename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AppInfoPacket.TitleName)
}

// string MetaDataPath = 4;
inline void AppInfoPacket::clear_metadatapath() {
  metadatapath_.ClearToEmpty();
}
inline const std::string& AppInfoPacket::metadatapath() const {
  // @@protoc_insertion_point(field_get:AppInfoPacket.MetaDataPath)
  return _internal_metadatapath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppInfoPacket::set_metadatapath(ArgT0&& arg0, ArgT... args) {
 
 metadatapath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AppInfoPacket.MetaDataPath)
}
inline std::string* AppInfoPacket::mutable_metadatapath() {
  std::string* _s = _internal_mutable_metadatapath();
  // @@protoc_insertion_point(field_mutable:AppInfoPacket.MetaDataPath)
  return _s;
}
inline const std::string& AppInfoPacket::_internal_metadatapath() const {
  return metadatapath_.Get();
}
inline void AppInfoPacket::_internal_set_metadatapath(const std::string& value) {
  
  metadatapath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AppInfoPacket::_internal_mutable_metadatapath() {
  
  return metadatapath_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppInfoPacket::release_metadatapath() {
  // @@protoc_insertion_point(field_release:AppInfoPacket.MetaDataPath)
  return metadatapath_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppInfoPacket::set_allocated_metadatapath(std::string* metadatapath) {
  if (metadatapath != nullptr) {
    
  } else {
    
  }
  metadatapath_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), metadatapath,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (metadatapath_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    metadatapath_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AppInfoPacket.MetaDataPath)
}

// string LastAccessTime = 5;
inline void AppInfoPacket::clear_lastaccesstime() {
  lastaccesstime_.ClearToEmpty();
}
inline const std::string& AppInfoPacket::lastaccesstime() const {
  // @@protoc_insertion_point(field_get:AppInfoPacket.LastAccessTime)
  return _internal_lastaccesstime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppInfoPacket::set_lastaccesstime(ArgT0&& arg0, ArgT... args) {
 
 lastaccesstime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AppInfoPacket.LastAccessTime)
}
inline std::string* AppInfoPacket::mutable_lastaccesstime() {
  std::string* _s = _internal_mutable_lastaccesstime();
  // @@protoc_insertion_point(field_mutable:AppInfoPacket.LastAccessTime)
  return _s;
}
inline const std::string& AppInfoPacket::_internal_lastaccesstime() const {
  return lastaccesstime_.Get();
}
inline void AppInfoPacket::_internal_set_lastaccesstime(const std::string& value) {
  
  lastaccesstime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AppInfoPacket::_internal_mutable_lastaccesstime() {
  
  return lastaccesstime_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppInfoPacket::release_lastaccesstime() {
  // @@protoc_insertion_point(field_release:AppInfoPacket.LastAccessTime)
  return lastaccesstime_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppInfoPacket::set_allocated_lastaccesstime(std::string* lastaccesstime) {
  if (lastaccesstime != nullptr) {
    
  } else {
    
  }
  lastaccesstime_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), lastaccesstime,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (lastaccesstime_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    lastaccesstime_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AppInfoPacket.LastAccessTime)
}

// bool IsVisible = 6;
inline void AppInfoPacket::clear_isvisible() {
  isvisible_ = false;
}
inline bool AppInfoPacket::_internal_isvisible() const {
  return isvisible_;
}
inline bool AppInfoPacket::isvisible() const {
  // @@protoc_insertion_point(field_get:AppInfoPacket.IsVisible)
  return _internal_isvisible();
}
inline void AppInfoPacket::_internal_set_isvisible(bool value) {
  
  isvisible_ = value;
}
inline void AppInfoPacket::set_isvisible(bool value) {
  _internal_set_isvisible(value);
  // @@protoc_insertion_point(field_set:AppInfoPacket.IsVisible)
}

// int32 SortPriority = 7;
inline void AppInfoPacket::clear_sortpriority() {
  sortpriority_ = 0;
}
inline int32_t AppInfoPacket::_internal_sortpriority() const {
  return sortpriority_;
}
inline int32_t AppInfoPacket::sortpriority() const {
  // @@protoc_insertion_point(field_get:AppInfoPacket.SortPriority)
  return _internal_sortpriority();
}
inline void AppInfoPacket::_internal_set_sortpriority(int32_t value) {
  
  sortpriority_ = value;
}
inline void AppInfoPacket::set_sortpriority(int32_t value) {
  _internal_set_sortpriority(value);
  // @@protoc_insertion_point(field_set:AppInfoPacket.SortPriority)
}

// int32 DispLocation = 8;
inline void AppInfoPacket::clear_displocation() {
  displocation_ = 0;
}
inline int32_t AppInfoPacket::_internal_displocation() const {
  return displocation_;
}
inline int32_t AppInfoPacket::displocation() const {
  // @@protoc_insertion_point(field_get:AppInfoPacket.DispLocation)
  return _internal_displocation();
}
inline void AppInfoPacket::_internal_set_displocation(int32_t value) {
  
  displocation_ = value;
}
inline void AppInfoPacket::set_displocation(int32_t value) {
  _internal_set_displocation(value);
  // @@protoc_insertion_point(field_set:AppInfoPacket.DispLocation)
}

// string Category = 9;
inline void AppInfoPacket::clear_category() {
  category_.ClearToEmpty();
}
inline const std::string& AppInfoPacket::category() const {
  // @@protoc_insertion_point(field_get:AppInfoPacket.Category)
  return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppInfoPacket::set_category(ArgT0&& arg0, ArgT... args) {
 
 category_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AppInfoPacket.Category)
}
inline std::string* AppInfoPacket::mutable_category() {
  std::string* _s = _internal_mutable_category();
  // @@protoc_insertion_point(field_mutable:AppInfoPacket.Category)
  return _s;
}
inline const std::string& AppInfoPacket::_internal_category() const {
  return category_.Get();
}
inline void AppInfoPacket::_internal_set_category(const std::string& value) {
  
  category_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AppInfoPacket::_internal_mutable_category() {
  
  return category_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppInfoPacket::release_category() {
  // @@protoc_insertion_point(field_release:AppInfoPacket.Category)
  return category_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppInfoPacket::set_allocated_category(std::string* category) {
  if (category != nullptr) {
    
  } else {
    
  }
  category_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), category,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (category_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    category_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AppInfoPacket.Category)
}

// int32 ContentSize = 10;
inline void AppInfoPacket::clear_contentsize() {
  contentsize_ = 0;
}
inline int32_t AppInfoPacket::_internal_contentsize() const {
  return contentsize_;
}
inline int32_t AppInfoPacket::contentsize() const {
  // @@protoc_insertion_point(field_get:AppInfoPacket.ContentSize)
  return _internal_contentsize();
}
inline void AppInfoPacket::_internal_set_contentsize(int32_t value) {
  
  contentsize_ = value;
}
inline void AppInfoPacket::set_contentsize(int32_t value) {
  _internal_set_contentsize(value);
  // @@protoc_insertion_point(field_set:AppInfoPacket.ContentSize)
}

// string InstallDate = 11;
inline void AppInfoPacket::clear_installdate() {
  installdate_.ClearToEmpty();
}
inline const std::string& AppInfoPacket::installdate() const {
  // @@protoc_insertion_point(field_get:AppInfoPacket.InstallDate)
  return _internal_installdate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppInfoPacket::set_installdate(ArgT0&& arg0, ArgT... args) {
 
 installdate_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AppInfoPacket.InstallDate)
}
inline std::string* AppInfoPacket::mutable_installdate() {
  std::string* _s = _internal_mutable_installdate();
  // @@protoc_insertion_point(field_mutable:AppInfoPacket.InstallDate)
  return _s;
}
inline const std::string& AppInfoPacket::_internal_installdate() const {
  return installdate_.Get();
}
inline void AppInfoPacket::_internal_set_installdate(const std::string& value) {
  
  installdate_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AppInfoPacket::_internal_mutable_installdate() {
  
  return installdate_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppInfoPacket::release_installdate() {
  // @@protoc_insertion_point(field_release:AppInfoPacket.InstallDate)
  return installdate_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppInfoPacket::set_allocated_installdate(std::string* installdate) {
  if (installdate != nullptr) {
    
  } else {
    
  }
  installdate_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), installdate,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (installdate_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    installdate_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AppInfoPacket.InstallDate)
}

// string UICategory = 12;
inline void AppInfoPacket::clear_uicategory() {
  uicategory_.ClearToEmpty();
}
inline const std::string& AppInfoPacket::uicategory() const {
  // @@protoc_insertion_point(field_get:AppInfoPacket.UICategory)
  return _internal_uicategory();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppInfoPacket::set_uicategory(ArgT0&& arg0, ArgT... args) {
 
 uicategory_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:AppInfoPacket.UICategory)
}
inline std::string* AppInfoPacket::mutable_uicategory() {
  std::string* _s = _internal_mutable_uicategory();
  // @@protoc_insertion_point(field_mutable:AppInfoPacket.UICategory)
  return _s;
}
inline const std::string& AppInfoPacket::_internal_uicategory() const {
  return uicategory_.Get();
}
inline void AppInfoPacket::_internal_set_uicategory(const std::string& value) {
  
  uicategory_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AppInfoPacket::_internal_mutable_uicategory() {
  
  return uicategory_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppInfoPacket::release_uicategory() {
  // @@protoc_insertion_point(field_release:AppInfoPacket.UICategory)
  return uicategory_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppInfoPacket::set_allocated_uicategory(std::string* uicategory) {
  if (uicategory != nullptr) {
    
  } else {
    
  }
  uicategory_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uicategory,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uicategory_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uicategory_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:AppInfoPacket.UICategory)
}

// -------------------------------------------------------------------

// RWPacket

// uint64 Address = 1;
inline void RWPacket::clear_address() {
  address_ = uint64_t{0u};
}
inline uint64_t RWPacket::_internal_address() const {
  return address_;
}
inline uint64_t RWPacket::address() const {
  // @@protoc_insertion_point(field_get:RWPacket.Address)
  return _internal_address();
}
inline void RWPacket::_internal_set_address(uint64_t value) {
  
  address_ = value;
}
inline void RWPacket::set_address(uint64_t value) {
  _internal_set_address(value);
  // @@protoc_insertion_point(field_set:RWPacket.Address)
}

// uint64 Length = 2;
inline void RWPacket::clear_length() {
  length_ = uint64_t{0u};
}
inline uint64_t RWPacket::_internal_length() const {
  return length_;
}
inline uint64_t RWPacket::length() const {
  // @@protoc_insertion_point(field_get:RWPacket.Length)
  return _internal_length();
}
inline void RWPacket::_internal_set_length(uint64_t value) {
  
  length_ = value;
}
inline void RWPacket::set_length(uint64_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:RWPacket.Length)
}

// -------------------------------------------------------------------

// SPRXPacket

// string Path = 1;
inline void SPRXPacket::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& SPRXPacket::path() const {
  // @@protoc_insertion_point(field_get:SPRXPacket.Path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SPRXPacket::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SPRXPacket.Path)
}
inline std::string* SPRXPacket::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:SPRXPacket.Path)
  return _s;
}
inline const std::string& SPRXPacket::_internal_path() const {
  return path_.Get();
}
inline void SPRXPacket::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SPRXPacket::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SPRXPacket::release_path() {
  // @@protoc_insertion_point(field_release:SPRXPacket.Path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SPRXPacket::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SPRXPacket.Path)
}

// int32 Handle = 2;
inline void SPRXPacket::clear_handle() {
  handle_ = 0;
}
inline int32_t SPRXPacket::_internal_handle() const {
  return handle_;
}
inline int32_t SPRXPacket::handle() const {
  // @@protoc_insertion_point(field_get:SPRXPacket.Handle)
  return _internal_handle();
}
inline void SPRXPacket::_internal_set_handle(int32_t value) {
  
  handle_ = value;
}
inline void SPRXPacket::set_handle(int32_t value) {
  _internal_set_handle(value);
  // @@protoc_insertion_point(field_set:SPRXPacket.Handle)
}

// -------------------------------------------------------------------

// MemoryInfo

// int32 Used = 1;
inline void MemoryInfo::clear_used() {
  used_ = 0;
}
inline int32_t MemoryInfo::_internal_used() const {
  return used_;
}
inline int32_t MemoryInfo::used() const {
  // @@protoc_insertion_point(field_get:MemoryInfo.Used)
  return _internal_used();
}
inline void MemoryInfo::_internal_set_used(int32_t value) {
  
  used_ = value;
}
inline void MemoryInfo::set_used(int32_t value) {
  _internal_set_used(value);
  // @@protoc_insertion_point(field_set:MemoryInfo.Used)
}

// int32 Free = 2;
inline void MemoryInfo::clear_free() {
  free_ = 0;
}
inline int32_t MemoryInfo::_internal_free() const {
  return free_;
}
inline int32_t MemoryInfo::free() const {
  // @@protoc_insertion_point(field_get:MemoryInfo.Free)
  return _internal_free();
}
inline void MemoryInfo::_internal_set_free(int32_t value) {
  
  free_ = value;
}
inline void MemoryInfo::set_free(int32_t value) {
  _internal_set_free(value);
  // @@protoc_insertion_point(field_set:MemoryInfo.Free)
}

// int32 Total = 3;
inline void MemoryInfo::clear_total() {
  total_ = 0;
}
inline int32_t MemoryInfo::_internal_total() const {
  return total_;
}
inline int32_t MemoryInfo::total() const {
  // @@protoc_insertion_point(field_get:MemoryInfo.Total)
  return _internal_total();
}
inline void MemoryInfo::_internal_set_total(int32_t value) {
  
  total_ = value;
}
inline void MemoryInfo::set_total(int32_t value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:MemoryInfo.Total)
}

// float Percentage = 4;
inline void MemoryInfo::clear_percentage() {
  percentage_ = 0;
}
inline float MemoryInfo::_internal_percentage() const {
  return percentage_;
}
inline float MemoryInfo::percentage() const {
  // @@protoc_insertion_point(field_get:MemoryInfo.Percentage)
  return _internal_percentage();
}
inline void MemoryInfo::_internal_set_percentage(float value) {
  
  percentage_ = value;
}
inline void MemoryInfo::set_percentage(float value) {
  _internal_set_percentage(value);
  // @@protoc_insertion_point(field_set:MemoryInfo.Percentage)
}

// -------------------------------------------------------------------

// CurrentBigApp

// int32 Pid = 1;
inline void CurrentBigApp::clear_pid() {
  pid_ = 0;
}
inline int32_t CurrentBigApp::_internal_pid() const {
  return pid_;
}
inline int32_t CurrentBigApp::pid() const {
  // @@protoc_insertion_point(field_get:CurrentBigApp.Pid)
  return _internal_pid();
}
inline void CurrentBigApp::_internal_set_pid(int32_t value) {
  
  pid_ = value;
}
inline void CurrentBigApp::set_pid(int32_t value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:CurrentBigApp.Pid)
}

// string Name = 2;
inline void CurrentBigApp::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& CurrentBigApp::name() const {
  // @@protoc_insertion_point(field_get:CurrentBigApp.Name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CurrentBigApp::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CurrentBigApp.Name)
}
inline std::string* CurrentBigApp::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CurrentBigApp.Name)
  return _s;
}
inline const std::string& CurrentBigApp::_internal_name() const {
  return name_.Get();
}
inline void CurrentBigApp::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CurrentBigApp::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CurrentBigApp::release_name() {
  // @@protoc_insertion_point(field_release:CurrentBigApp.Name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CurrentBigApp::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CurrentBigApp.Name)
}

// string TitleId = 3;
inline void CurrentBigApp::clear_titleid() {
  titleid_.ClearToEmpty();
}
inline const std::string& CurrentBigApp::titleid() const {
  // @@protoc_insertion_point(field_get:CurrentBigApp.TitleId)
  return _internal_titleid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CurrentBigApp::set_titleid(ArgT0&& arg0, ArgT... args) {
 
 titleid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CurrentBigApp.TitleId)
}
inline std::string* CurrentBigApp::mutable_titleid() {
  std::string* _s = _internal_mutable_titleid();
  // @@protoc_insertion_point(field_mutable:CurrentBigApp.TitleId)
  return _s;
}
inline const std::string& CurrentBigApp::_internal_titleid() const {
  return titleid_.Get();
}
inline void CurrentBigApp::_internal_set_titleid(const std::string& value) {
  
  titleid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CurrentBigApp::_internal_mutable_titleid() {
  
  return titleid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CurrentBigApp::release_titleid() {
  // @@protoc_insertion_point(field_release:CurrentBigApp.TitleId)
  return titleid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CurrentBigApp::set_allocated_titleid(std::string* titleid) {
  if (titleid != nullptr) {
    
  } else {
    
  }
  titleid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), titleid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (titleid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    titleid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CurrentBigApp.TitleId)
}

// -------------------------------------------------------------------

// TargetInfoPacket

// int32 SDKVersion = 1;
inline void TargetInfoPacket::clear_sdkversion() {
  sdkversion_ = 0;
}
inline int32_t TargetInfoPacket::_internal_sdkversion() const {
  return sdkversion_;
}
inline int32_t TargetInfoPacket::sdkversion() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.SDKVersion)
  return _internal_sdkversion();
}
inline void TargetInfoPacket::_internal_set_sdkversion(int32_t value) {
  
  sdkversion_ = value;
}
inline void TargetInfoPacket::set_sdkversion(int32_t value) {
  _internal_set_sdkversion(value);
  // @@protoc_insertion_point(field_set:TargetInfoPacket.SDKVersion)
}

// int32 SoftwareVersion = 2;
inline void TargetInfoPacket::clear_softwareversion() {
  softwareversion_ = 0;
}
inline int32_t TargetInfoPacket::_internal_softwareversion() const {
  return softwareversion_;
}
inline int32_t TargetInfoPacket::softwareversion() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.SoftwareVersion)
  return _internal_softwareversion();
}
inline void TargetInfoPacket::_internal_set_softwareversion(int32_t value) {
  
  softwareversion_ = value;
}
inline void TargetInfoPacket::set_softwareversion(int32_t value) {
  _internal_set_softwareversion(value);
  // @@protoc_insertion_point(field_set:TargetInfoPacket.SoftwareVersion)
}

// int32 FactorySoftwareVersion = 3;
inline void TargetInfoPacket::clear_factorysoftwareversion() {
  factorysoftwareversion_ = 0;
}
inline int32_t TargetInfoPacket::_internal_factorysoftwareversion() const {
  return factorysoftwareversion_;
}
inline int32_t TargetInfoPacket::factorysoftwareversion() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.FactorySoftwareVersion)
  return _internal_factorysoftwareversion();
}
inline void TargetInfoPacket::_internal_set_factorysoftwareversion(int32_t value) {
  
  factorysoftwareversion_ = value;
}
inline void TargetInfoPacket::set_factorysoftwareversion(int32_t value) {
  _internal_set_factorysoftwareversion(value);
  // @@protoc_insertion_point(field_set:TargetInfoPacket.FactorySoftwareVersion)
}

// .CurrentBigApp BigApp = 4;
inline bool TargetInfoPacket::_internal_has_bigapp() const {
  return this != internal_default_instance() && bigapp_ != nullptr;
}
inline bool TargetInfoPacket::has_bigapp() const {
  return _internal_has_bigapp();
}
inline void TargetInfoPacket::clear_bigapp() {
  if (GetArenaForAllocation() == nullptr && bigapp_ != nullptr) {
    delete bigapp_;
  }
  bigapp_ = nullptr;
}
inline const ::CurrentBigApp& TargetInfoPacket::_internal_bigapp() const {
  const ::CurrentBigApp* p = bigapp_;
  return p != nullptr ? *p : reinterpret_cast<const ::CurrentBigApp&>(
      ::_CurrentBigApp_default_instance_);
}
inline const ::CurrentBigApp& TargetInfoPacket::bigapp() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.BigApp)
  return _internal_bigapp();
}
inline void TargetInfoPacket::unsafe_arena_set_allocated_bigapp(
    ::CurrentBigApp* bigapp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bigapp_);
  }
  bigapp_ = bigapp;
  if (bigapp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TargetInfoPacket.BigApp)
}
inline ::CurrentBigApp* TargetInfoPacket::release_bigapp() {
  
  ::CurrentBigApp* temp = bigapp_;
  bigapp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CurrentBigApp* TargetInfoPacket::unsafe_arena_release_bigapp() {
  // @@protoc_insertion_point(field_release:TargetInfoPacket.BigApp)
  
  ::CurrentBigApp* temp = bigapp_;
  bigapp_ = nullptr;
  return temp;
}
inline ::CurrentBigApp* TargetInfoPacket::_internal_mutable_bigapp() {
  
  if (bigapp_ == nullptr) {
    auto* p = CreateMaybeMessage<::CurrentBigApp>(GetArenaForAllocation());
    bigapp_ = p;
  }
  return bigapp_;
}
inline ::CurrentBigApp* TargetInfoPacket::mutable_bigapp() {
  ::CurrentBigApp* _msg = _internal_mutable_bigapp();
  // @@protoc_insertion_point(field_mutable:TargetInfoPacket.BigApp)
  return _msg;
}
inline void TargetInfoPacket::set_allocated_bigapp(::CurrentBigApp* bigapp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete bigapp_;
  }
  if (bigapp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CurrentBigApp>::GetOwningArena(bigapp);
    if (message_arena != submessage_arena) {
      bigapp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bigapp, submessage_arena);
    }
    
  } else {
    
  }
  bigapp_ = bigapp;
  // @@protoc_insertion_point(field_set_allocated:TargetInfoPacket.BigApp)
}

// string ConsoleName = 5;
inline void TargetInfoPacket::clear_consolename() {
  consolename_.ClearToEmpty();
}
inline const std::string& TargetInfoPacket::consolename() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.ConsoleName)
  return _internal_consolename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TargetInfoPacket::set_consolename(ArgT0&& arg0, ArgT... args) {
 
 consolename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TargetInfoPacket.ConsoleName)
}
inline std::string* TargetInfoPacket::mutable_consolename() {
  std::string* _s = _internal_mutable_consolename();
  // @@protoc_insertion_point(field_mutable:TargetInfoPacket.ConsoleName)
  return _s;
}
inline const std::string& TargetInfoPacket::_internal_consolename() const {
  return consolename_.Get();
}
inline void TargetInfoPacket::_internal_set_consolename(const std::string& value) {
  
  consolename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TargetInfoPacket::_internal_mutable_consolename() {
  
  return consolename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TargetInfoPacket::release_consolename() {
  // @@protoc_insertion_point(field_release:TargetInfoPacket.ConsoleName)
  return consolename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TargetInfoPacket::set_allocated_consolename(std::string* consolename) {
  if (consolename != nullptr) {
    
  } else {
    
  }
  consolename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), consolename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (consolename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    consolename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TargetInfoPacket.ConsoleName)
}

// string MotherboardSerial = 6;
inline void TargetInfoPacket::clear_motherboardserial() {
  motherboardserial_.ClearToEmpty();
}
inline const std::string& TargetInfoPacket::motherboardserial() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.MotherboardSerial)
  return _internal_motherboardserial();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TargetInfoPacket::set_motherboardserial(ArgT0&& arg0, ArgT... args) {
 
 motherboardserial_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TargetInfoPacket.MotherboardSerial)
}
inline std::string* TargetInfoPacket::mutable_motherboardserial() {
  std::string* _s = _internal_mutable_motherboardserial();
  // @@protoc_insertion_point(field_mutable:TargetInfoPacket.MotherboardSerial)
  return _s;
}
inline const std::string& TargetInfoPacket::_internal_motherboardserial() const {
  return motherboardserial_.Get();
}
inline void TargetInfoPacket::_internal_set_motherboardserial(const std::string& value) {
  
  motherboardserial_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TargetInfoPacket::_internal_mutable_motherboardserial() {
  
  return motherboardserial_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TargetInfoPacket::release_motherboardserial() {
  // @@protoc_insertion_point(field_release:TargetInfoPacket.MotherboardSerial)
  return motherboardserial_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TargetInfoPacket::set_allocated_motherboardserial(std::string* motherboardserial) {
  if (motherboardserial != nullptr) {
    
  } else {
    
  }
  motherboardserial_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), motherboardserial,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (motherboardserial_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    motherboardserial_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TargetInfoPacket.MotherboardSerial)
}

// string Serial = 7;
inline void TargetInfoPacket::clear_serial() {
  serial_.ClearToEmpty();
}
inline const std::string& TargetInfoPacket::serial() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.Serial)
  return _internal_serial();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TargetInfoPacket::set_serial(ArgT0&& arg0, ArgT... args) {
 
 serial_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TargetInfoPacket.Serial)
}
inline std::string* TargetInfoPacket::mutable_serial() {
  std::string* _s = _internal_mutable_serial();
  // @@protoc_insertion_point(field_mutable:TargetInfoPacket.Serial)
  return _s;
}
inline const std::string& TargetInfoPacket::_internal_serial() const {
  return serial_.Get();
}
inline void TargetInfoPacket::_internal_set_serial(const std::string& value) {
  
  serial_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TargetInfoPacket::_internal_mutable_serial() {
  
  return serial_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TargetInfoPacket::release_serial() {
  // @@protoc_insertion_point(field_release:TargetInfoPacket.Serial)
  return serial_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TargetInfoPacket::set_allocated_serial(std::string* serial) {
  if (serial != nullptr) {
    
  } else {
    
  }
  serial_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serial,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (serial_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    serial_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TargetInfoPacket.Serial)
}

// string Model = 8;
inline void TargetInfoPacket::clear_model() {
  model_.ClearToEmpty();
}
inline const std::string& TargetInfoPacket::model() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.Model)
  return _internal_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TargetInfoPacket::set_model(ArgT0&& arg0, ArgT... args) {
 
 model_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TargetInfoPacket.Model)
}
inline std::string* TargetInfoPacket::mutable_model() {
  std::string* _s = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:TargetInfoPacket.Model)
  return _s;
}
inline const std::string& TargetInfoPacket::_internal_model() const {
  return model_.Get();
}
inline void TargetInfoPacket::_internal_set_model(const std::string& value) {
  
  model_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TargetInfoPacket::_internal_mutable_model() {
  
  return model_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TargetInfoPacket::release_model() {
  // @@protoc_insertion_point(field_release:TargetInfoPacket.Model)
  return model_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TargetInfoPacket::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    
  } else {
    
  }
  model_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    model_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TargetInfoPacket.Model)
}

// string MACAdressLAN = 9;
inline void TargetInfoPacket::clear_macadresslan() {
  macadresslan_.ClearToEmpty();
}
inline const std::string& TargetInfoPacket::macadresslan() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.MACAdressLAN)
  return _internal_macadresslan();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TargetInfoPacket::set_macadresslan(ArgT0&& arg0, ArgT... args) {
 
 macadresslan_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TargetInfoPacket.MACAdressLAN)
}
inline std::string* TargetInfoPacket::mutable_macadresslan() {
  std::string* _s = _internal_mutable_macadresslan();
  // @@protoc_insertion_point(field_mutable:TargetInfoPacket.MACAdressLAN)
  return _s;
}
inline const std::string& TargetInfoPacket::_internal_macadresslan() const {
  return macadresslan_.Get();
}
inline void TargetInfoPacket::_internal_set_macadresslan(const std::string& value) {
  
  macadresslan_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TargetInfoPacket::_internal_mutable_macadresslan() {
  
  return macadresslan_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TargetInfoPacket::release_macadresslan() {
  // @@protoc_insertion_point(field_release:TargetInfoPacket.MACAdressLAN)
  return macadresslan_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TargetInfoPacket::set_allocated_macadresslan(std::string* macadresslan) {
  if (macadresslan != nullptr) {
    
  } else {
    
  }
  macadresslan_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), macadresslan,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (macadresslan_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    macadresslan_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TargetInfoPacket.MACAdressLAN)
}

// string MACAdressWIFI = 10;
inline void TargetInfoPacket::clear_macadresswifi() {
  macadresswifi_.ClearToEmpty();
}
inline const std::string& TargetInfoPacket::macadresswifi() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.MACAdressWIFI)
  return _internal_macadresswifi();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TargetInfoPacket::set_macadresswifi(ArgT0&& arg0, ArgT... args) {
 
 macadresswifi_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TargetInfoPacket.MACAdressWIFI)
}
inline std::string* TargetInfoPacket::mutable_macadresswifi() {
  std::string* _s = _internal_mutable_macadresswifi();
  // @@protoc_insertion_point(field_mutable:TargetInfoPacket.MACAdressWIFI)
  return _s;
}
inline const std::string& TargetInfoPacket::_internal_macadresswifi() const {
  return macadresswifi_.Get();
}
inline void TargetInfoPacket::_internal_set_macadresswifi(const std::string& value) {
  
  macadresswifi_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TargetInfoPacket::_internal_mutable_macadresswifi() {
  
  return macadresswifi_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TargetInfoPacket::release_macadresswifi() {
  // @@protoc_insertion_point(field_release:TargetInfoPacket.MACAdressWIFI)
  return macadresswifi_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TargetInfoPacket::set_allocated_macadresswifi(std::string* macadresswifi) {
  if (macadresswifi != nullptr) {
    
  } else {
    
  }
  macadresswifi_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), macadresswifi,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (macadresswifi_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    macadresswifi_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TargetInfoPacket.MACAdressWIFI)
}

// bool UART = 11;
inline void TargetInfoPacket::clear_uart() {
  uart_ = false;
}
inline bool TargetInfoPacket::_internal_uart() const {
  return uart_;
}
inline bool TargetInfoPacket::uart() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.UART)
  return _internal_uart();
}
inline void TargetInfoPacket::_internal_set_uart(bool value) {
  
  uart_ = value;
}
inline void TargetInfoPacket::set_uart(bool value) {
  _internal_set_uart(value);
  // @@protoc_insertion_point(field_set:TargetInfoPacket.UART)
}

// bool IDUMode = 12;
inline void TargetInfoPacket::clear_idumode() {
  idumode_ = false;
}
inline bool TargetInfoPacket::_internal_idumode() const {
  return idumode_;
}
inline bool TargetInfoPacket::idumode() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.IDUMode)
  return _internal_idumode();
}
inline void TargetInfoPacket::_internal_set_idumode(bool value) {
  
  idumode_ = value;
}
inline void TargetInfoPacket::set_idumode(bool value) {
  _internal_set_idumode(value);
  // @@protoc_insertion_point(field_set:TargetInfoPacket.IDUMode)
}

// string IDPS = 13;
inline void TargetInfoPacket::clear_idps() {
  idps_.ClearToEmpty();
}
inline const std::string& TargetInfoPacket::idps() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.IDPS)
  return _internal_idps();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TargetInfoPacket::set_idps(ArgT0&& arg0, ArgT... args) {
 
 idps_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TargetInfoPacket.IDPS)
}
inline std::string* TargetInfoPacket::mutable_idps() {
  std::string* _s = _internal_mutable_idps();
  // @@protoc_insertion_point(field_mutable:TargetInfoPacket.IDPS)
  return _s;
}
inline const std::string& TargetInfoPacket::_internal_idps() const {
  return idps_.Get();
}
inline void TargetInfoPacket::_internal_set_idps(const std::string& value) {
  
  idps_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TargetInfoPacket::_internal_mutable_idps() {
  
  return idps_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TargetInfoPacket::release_idps() {
  // @@protoc_insertion_point(field_release:TargetInfoPacket.IDPS)
  return idps_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TargetInfoPacket::set_allocated_idps(std::string* idps) {
  if (idps != nullptr) {
    
  } else {
    
  }
  idps_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), idps,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (idps_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    idps_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TargetInfoPacket.IDPS)
}

// string PSID = 14;
inline void TargetInfoPacket::clear_psid() {
  psid_.ClearToEmpty();
}
inline const std::string& TargetInfoPacket::psid() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.PSID)
  return _internal_psid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TargetInfoPacket::set_psid(ArgT0&& arg0, ArgT... args) {
 
 psid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TargetInfoPacket.PSID)
}
inline std::string* TargetInfoPacket::mutable_psid() {
  std::string* _s = _internal_mutable_psid();
  // @@protoc_insertion_point(field_mutable:TargetInfoPacket.PSID)
  return _s;
}
inline const std::string& TargetInfoPacket::_internal_psid() const {
  return psid_.Get();
}
inline void TargetInfoPacket::_internal_set_psid(const std::string& value) {
  
  psid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TargetInfoPacket::_internal_mutable_psid() {
  
  return psid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TargetInfoPacket::release_psid() {
  // @@protoc_insertion_point(field_release:TargetInfoPacket.PSID)
  return psid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TargetInfoPacket::set_allocated_psid(std::string* psid) {
  if (psid != nullptr) {
    
  } else {
    
  }
  psid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), psid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (psid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    psid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TargetInfoPacket.PSID)
}

// int32 ConsoleType = 15;
inline void TargetInfoPacket::clear_consoletype() {
  consoletype_ = 0;
}
inline int32_t TargetInfoPacket::_internal_consoletype() const {
  return consoletype_;
}
inline int32_t TargetInfoPacket::consoletype() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.ConsoleType)
  return _internal_consoletype();
}
inline void TargetInfoPacket::_internal_set_consoletype(int32_t value) {
  
  consoletype_ = value;
}
inline void TargetInfoPacket::set_consoletype(int32_t value) {
  _internal_set_consoletype(value);
  // @@protoc_insertion_point(field_set:TargetInfoPacket.ConsoleType)
}

// int32 Attached = 16;
inline void TargetInfoPacket::clear_attached() {
  attached_ = 0;
}
inline int32_t TargetInfoPacket::_internal_attached() const {
  return attached_;
}
inline int32_t TargetInfoPacket::attached() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.Attached)
  return _internal_attached();
}
inline void TargetInfoPacket::_internal_set_attached(int32_t value) {
  
  attached_ = value;
}
inline void TargetInfoPacket::set_attached(int32_t value) {
  _internal_set_attached(value);
  // @@protoc_insertion_point(field_set:TargetInfoPacket.Attached)
}

// int32 AttachedPid = 17;
inline void TargetInfoPacket::clear_attachedpid() {
  attachedpid_ = 0;
}
inline int32_t TargetInfoPacket::_internal_attachedpid() const {
  return attachedpid_;
}
inline int32_t TargetInfoPacket::attachedpid() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.AttachedPid)
  return _internal_attachedpid();
}
inline void TargetInfoPacket::_internal_set_attachedpid(int32_t value) {
  
  attachedpid_ = value;
}
inline void TargetInfoPacket::set_attachedpid(int32_t value) {
  _internal_set_attachedpid(value);
  // @@protoc_insertion_point(field_set:TargetInfoPacket.AttachedPid)
}

// int32 ForegroundAccountId = 18;
inline void TargetInfoPacket::clear_foregroundaccountid() {
  foregroundaccountid_ = 0;
}
inline int32_t TargetInfoPacket::_internal_foregroundaccountid() const {
  return foregroundaccountid_;
}
inline int32_t TargetInfoPacket::foregroundaccountid() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.ForegroundAccountId)
  return _internal_foregroundaccountid();
}
inline void TargetInfoPacket::_internal_set_foregroundaccountid(int32_t value) {
  
  foregroundaccountid_ = value;
}
inline void TargetInfoPacket::set_foregroundaccountid(int32_t value) {
  _internal_set_foregroundaccountid(value);
  // @@protoc_insertion_point(field_set:TargetInfoPacket.ForegroundAccountId)
}

// uint64 FreeSpace = 19;
inline void TargetInfoPacket::clear_freespace() {
  freespace_ = uint64_t{0u};
}
inline uint64_t TargetInfoPacket::_internal_freespace() const {
  return freespace_;
}
inline uint64_t TargetInfoPacket::freespace() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.FreeSpace)
  return _internal_freespace();
}
inline void TargetInfoPacket::_internal_set_freespace(uint64_t value) {
  
  freespace_ = value;
}
inline void TargetInfoPacket::set_freespace(uint64_t value) {
  _internal_set_freespace(value);
  // @@protoc_insertion_point(field_set:TargetInfoPacket.FreeSpace)
}

// uint64 TotalSpace = 20;
inline void TargetInfoPacket::clear_totalspace() {
  totalspace_ = uint64_t{0u};
}
inline uint64_t TargetInfoPacket::_internal_totalspace() const {
  return totalspace_;
}
inline uint64_t TargetInfoPacket::totalspace() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.TotalSpace)
  return _internal_totalspace();
}
inline void TargetInfoPacket::_internal_set_totalspace(uint64_t value) {
  
  totalspace_ = value;
}
inline void TargetInfoPacket::set_totalspace(uint64_t value) {
  _internal_set_totalspace(value);
  // @@protoc_insertion_point(field_set:TargetInfoPacket.TotalSpace)
}

// int32 CPUTemp = 21;
inline void TargetInfoPacket::clear_cputemp() {
  cputemp_ = 0;
}
inline int32_t TargetInfoPacket::_internal_cputemp() const {
  return cputemp_;
}
inline int32_t TargetInfoPacket::cputemp() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.CPUTemp)
  return _internal_cputemp();
}
inline void TargetInfoPacket::_internal_set_cputemp(int32_t value) {
  
  cputemp_ = value;
}
inline void TargetInfoPacket::set_cputemp(int32_t value) {
  _internal_set_cputemp(value);
  // @@protoc_insertion_point(field_set:TargetInfoPacket.CPUTemp)
}

// int32 SOCTemp = 22;
inline void TargetInfoPacket::clear_soctemp() {
  soctemp_ = 0;
}
inline int32_t TargetInfoPacket::_internal_soctemp() const {
  return soctemp_;
}
inline int32_t TargetInfoPacket::soctemp() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.SOCTemp)
  return _internal_soctemp();
}
inline void TargetInfoPacket::_internal_set_soctemp(int32_t value) {
  
  soctemp_ = value;
}
inline void TargetInfoPacket::set_soctemp(int32_t value) {
  _internal_set_soctemp(value);
  // @@protoc_insertion_point(field_set:TargetInfoPacket.SOCTemp)
}

// int32 ThreadCount = 23;
inline void TargetInfoPacket::clear_threadcount() {
  threadcount_ = 0;
}
inline int32_t TargetInfoPacket::_internal_threadcount() const {
  return threadcount_;
}
inline int32_t TargetInfoPacket::threadcount() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.ThreadCount)
  return _internal_threadcount();
}
inline void TargetInfoPacket::_internal_set_threadcount(int32_t value) {
  
  threadcount_ = value;
}
inline void TargetInfoPacket::set_threadcount(int32_t value) {
  _internal_set_threadcount(value);
  // @@protoc_insertion_point(field_set:TargetInfoPacket.ThreadCount)
}

// float AverageCPUUsage = 24;
inline void TargetInfoPacket::clear_averagecpuusage() {
  averagecpuusage_ = 0;
}
inline float TargetInfoPacket::_internal_averagecpuusage() const {
  return averagecpuusage_;
}
inline float TargetInfoPacket::averagecpuusage() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.AverageCPUUsage)
  return _internal_averagecpuusage();
}
inline void TargetInfoPacket::_internal_set_averagecpuusage(float value) {
  
  averagecpuusage_ = value;
}
inline void TargetInfoPacket::set_averagecpuusage(float value) {
  _internal_set_averagecpuusage(value);
  // @@protoc_insertion_point(field_set:TargetInfoPacket.AverageCPUUsage)
}

// int32 BusyCore = 25;
inline void TargetInfoPacket::clear_busycore() {
  busycore_ = 0;
}
inline int32_t TargetInfoPacket::_internal_busycore() const {
  return busycore_;
}
inline int32_t TargetInfoPacket::busycore() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.BusyCore)
  return _internal_busycore();
}
inline void TargetInfoPacket::_internal_set_busycore(int32_t value) {
  
  busycore_ = value;
}
inline void TargetInfoPacket::set_busycore(int32_t value) {
  _internal_set_busycore(value);
  // @@protoc_insertion_point(field_set:TargetInfoPacket.BusyCore)
}

// .MemoryInfo Ram = 26;
inline bool TargetInfoPacket::_internal_has_ram() const {
  return this != internal_default_instance() && ram_ != nullptr;
}
inline bool TargetInfoPacket::has_ram() const {
  return _internal_has_ram();
}
inline void TargetInfoPacket::clear_ram() {
  if (GetArenaForAllocation() == nullptr && ram_ != nullptr) {
    delete ram_;
  }
  ram_ = nullptr;
}
inline const ::MemoryInfo& TargetInfoPacket::_internal_ram() const {
  const ::MemoryInfo* p = ram_;
  return p != nullptr ? *p : reinterpret_cast<const ::MemoryInfo&>(
      ::_MemoryInfo_default_instance_);
}
inline const ::MemoryInfo& TargetInfoPacket::ram() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.Ram)
  return _internal_ram();
}
inline void TargetInfoPacket::unsafe_arena_set_allocated_ram(
    ::MemoryInfo* ram) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ram_);
  }
  ram_ = ram;
  if (ram) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TargetInfoPacket.Ram)
}
inline ::MemoryInfo* TargetInfoPacket::release_ram() {
  
  ::MemoryInfo* temp = ram_;
  ram_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MemoryInfo* TargetInfoPacket::unsafe_arena_release_ram() {
  // @@protoc_insertion_point(field_release:TargetInfoPacket.Ram)
  
  ::MemoryInfo* temp = ram_;
  ram_ = nullptr;
  return temp;
}
inline ::MemoryInfo* TargetInfoPacket::_internal_mutable_ram() {
  
  if (ram_ == nullptr) {
    auto* p = CreateMaybeMessage<::MemoryInfo>(GetArenaForAllocation());
    ram_ = p;
  }
  return ram_;
}
inline ::MemoryInfo* TargetInfoPacket::mutable_ram() {
  ::MemoryInfo* _msg = _internal_mutable_ram();
  // @@protoc_insertion_point(field_mutable:TargetInfoPacket.Ram)
  return _msg;
}
inline void TargetInfoPacket::set_allocated_ram(::MemoryInfo* ram) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete ram_;
  }
  if (ram) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::MemoryInfo>::GetOwningArena(ram);
    if (message_arena != submessage_arena) {
      ram = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ram, submessage_arena);
    }
    
  } else {
    
  }
  ram_ = ram;
  // @@protoc_insertion_point(field_set_allocated:TargetInfoPacket.Ram)
}

// .MemoryInfo VRam = 27;
inline bool TargetInfoPacket::_internal_has_vram() const {
  return this != internal_default_instance() && vram_ != nullptr;
}
inline bool TargetInfoPacket::has_vram() const {
  return _internal_has_vram();
}
inline void TargetInfoPacket::clear_vram() {
  if (GetArenaForAllocation() == nullptr && vram_ != nullptr) {
    delete vram_;
  }
  vram_ = nullptr;
}
inline const ::MemoryInfo& TargetInfoPacket::_internal_vram() const {
  const ::MemoryInfo* p = vram_;
  return p != nullptr ? *p : reinterpret_cast<const ::MemoryInfo&>(
      ::_MemoryInfo_default_instance_);
}
inline const ::MemoryInfo& TargetInfoPacket::vram() const {
  // @@protoc_insertion_point(field_get:TargetInfoPacket.VRam)
  return _internal_vram();
}
inline void TargetInfoPacket::unsafe_arena_set_allocated_vram(
    ::MemoryInfo* vram) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vram_);
  }
  vram_ = vram;
  if (vram) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TargetInfoPacket.VRam)
}
inline ::MemoryInfo* TargetInfoPacket::release_vram() {
  
  ::MemoryInfo* temp = vram_;
  vram_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::MemoryInfo* TargetInfoPacket::unsafe_arena_release_vram() {
  // @@protoc_insertion_point(field_release:TargetInfoPacket.VRam)
  
  ::MemoryInfo* temp = vram_;
  vram_ = nullptr;
  return temp;
}
inline ::MemoryInfo* TargetInfoPacket::_internal_mutable_vram() {
  
  if (vram_ == nullptr) {
    auto* p = CreateMaybeMessage<::MemoryInfo>(GetArenaForAllocation());
    vram_ = p;
  }
  return vram_;
}
inline ::MemoryInfo* TargetInfoPacket::mutable_vram() {
  ::MemoryInfo* _msg = _internal_mutable_vram();
  // @@protoc_insertion_point(field_mutable:TargetInfoPacket.VRam)
  return _msg;
}
inline void TargetInfoPacket::set_allocated_vram(::MemoryInfo* vram) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete vram_;
  }
  if (vram) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::MemoryInfo>::GetOwningArena(vram);
    if (message_arena != submessage_arena) {
      vram = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vram, submessage_arena);
    }
    
  } else {
    
  }
  vram_ = vram;
  // @@protoc_insertion_point(field_set_allocated:TargetInfoPacket.VRam)
}

// -------------------------------------------------------------------

// TargetNotifyPacket

// string IconURI = 1;
inline void TargetNotifyPacket::clear_iconuri() {
  iconuri_.ClearToEmpty();
}
inline const std::string& TargetNotifyPacket::iconuri() const {
  // @@protoc_insertion_point(field_get:TargetNotifyPacket.IconURI)
  return _internal_iconuri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TargetNotifyPacket::set_iconuri(ArgT0&& arg0, ArgT... args) {
 
 iconuri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TargetNotifyPacket.IconURI)
}
inline std::string* TargetNotifyPacket::mutable_iconuri() {
  std::string* _s = _internal_mutable_iconuri();
  // @@protoc_insertion_point(field_mutable:TargetNotifyPacket.IconURI)
  return _s;
}
inline const std::string& TargetNotifyPacket::_internal_iconuri() const {
  return iconuri_.Get();
}
inline void TargetNotifyPacket::_internal_set_iconuri(const std::string& value) {
  
  iconuri_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TargetNotifyPacket::_internal_mutable_iconuri() {
  
  return iconuri_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TargetNotifyPacket::release_iconuri() {
  // @@protoc_insertion_point(field_release:TargetNotifyPacket.IconURI)
  return iconuri_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TargetNotifyPacket::set_allocated_iconuri(std::string* iconuri) {
  if (iconuri != nullptr) {
    
  } else {
    
  }
  iconuri_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), iconuri,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (iconuri_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    iconuri_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TargetNotifyPacket.IconURI)
}

// string Message = 2;
inline void TargetNotifyPacket::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& TargetNotifyPacket::message() const {
  // @@protoc_insertion_point(field_get:TargetNotifyPacket.Message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TargetNotifyPacket::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TargetNotifyPacket.Message)
}
inline std::string* TargetNotifyPacket::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:TargetNotifyPacket.Message)
  return _s;
}
inline const std::string& TargetNotifyPacket::_internal_message() const {
  return message_.Get();
}
inline void TargetNotifyPacket::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TargetNotifyPacket::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TargetNotifyPacket::release_message() {
  // @@protoc_insertion_point(field_release:TargetNotifyPacket.Message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TargetNotifyPacket::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TargetNotifyPacket.Message)
}

// -------------------------------------------------------------------

// ProcPacket

// int32 AppId = 1;
inline void ProcPacket::clear_appid() {
  appid_ = 0;
}
inline int32_t ProcPacket::_internal_appid() const {
  return appid_;
}
inline int32_t ProcPacket::appid() const {
  // @@protoc_insertion_point(field_get:ProcPacket.AppId)
  return _internal_appid();
}
inline void ProcPacket::_internal_set_appid(int32_t value) {
  
  appid_ = value;
}
inline void ProcPacket::set_appid(int32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:ProcPacket.AppId)
}

// int32 ProcessId = 2;
inline void ProcPacket::clear_processid() {
  processid_ = 0;
}
inline int32_t ProcPacket::_internal_processid() const {
  return processid_;
}
inline int32_t ProcPacket::processid() const {
  // @@protoc_insertion_point(field_get:ProcPacket.ProcessId)
  return _internal_processid();
}
inline void ProcPacket::_internal_set_processid(int32_t value) {
  
  processid_ = value;
}
inline void ProcPacket::set_processid(int32_t value) {
  _internal_set_processid(value);
  // @@protoc_insertion_point(field_set:ProcPacket.ProcessId)
}

// string Name = 3;
inline void ProcPacket::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& ProcPacket::name() const {
  // @@protoc_insertion_point(field_get:ProcPacket.Name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcPacket::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcPacket.Name)
}
inline std::string* ProcPacket::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:ProcPacket.Name)
  return _s;
}
inline const std::string& ProcPacket::_internal_name() const {
  return name_.Get();
}
inline void ProcPacket::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ProcPacket::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ProcPacket::release_name() {
  // @@protoc_insertion_point(field_release:ProcPacket.Name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ProcPacket::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcPacket.Name)
}

// string TitleId = 4;
inline void ProcPacket::clear_titleid() {
  titleid_.ClearToEmpty();
}
inline const std::string& ProcPacket::titleid() const {
  // @@protoc_insertion_point(field_get:ProcPacket.TitleId)
  return _internal_titleid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProcPacket::set_titleid(ArgT0&& arg0, ArgT... args) {
 
 titleid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ProcPacket.TitleId)
}
inline std::string* ProcPacket::mutable_titleid() {
  std::string* _s = _internal_mutable_titleid();
  // @@protoc_insertion_point(field_mutable:ProcPacket.TitleId)
  return _s;
}
inline const std::string& ProcPacket::_internal_titleid() const {
  return titleid_.Get();
}
inline void ProcPacket::_internal_set_titleid(const std::string& value) {
  
  titleid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ProcPacket::_internal_mutable_titleid() {
  
  return titleid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ProcPacket::release_titleid() {
  // @@protoc_insertion_point(field_release:ProcPacket.TitleId)
  return titleid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ProcPacket::set_allocated_titleid(std::string* titleid) {
  if (titleid != nullptr) {
    
  } else {
    
  }
  titleid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), titleid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (titleid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    titleid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ProcPacket.TitleId)
}

// -------------------------------------------------------------------

// LibraryInfoPacket

// uint32 Handle = 1;
inline void LibraryInfoPacket::clear_handle() {
  handle_ = 0u;
}
inline uint32_t LibraryInfoPacket::_internal_handle() const {
  return handle_;
}
inline uint32_t LibraryInfoPacket::handle() const {
  // @@protoc_insertion_point(field_get:LibraryInfoPacket.Handle)
  return _internal_handle();
}
inline void LibraryInfoPacket::_internal_set_handle(uint32_t value) {
  
  handle_ = value;
}
inline void LibraryInfoPacket::set_handle(uint32_t value) {
  _internal_set_handle(value);
  // @@protoc_insertion_point(field_set:LibraryInfoPacket.Handle)
}

// string Path = 2;
inline void LibraryInfoPacket::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& LibraryInfoPacket::path() const {
  // @@protoc_insertion_point(field_get:LibraryInfoPacket.Path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LibraryInfoPacket::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LibraryInfoPacket.Path)
}
inline std::string* LibraryInfoPacket::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:LibraryInfoPacket.Path)
  return _s;
}
inline const std::string& LibraryInfoPacket::_internal_path() const {
  return path_.Get();
}
inline void LibraryInfoPacket::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LibraryInfoPacket::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LibraryInfoPacket::release_path() {
  // @@protoc_insertion_point(field_release:LibraryInfoPacket.Path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LibraryInfoPacket::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:LibraryInfoPacket.Path)
}

// uint64 MapBase = 3;
inline void LibraryInfoPacket::clear_mapbase() {
  mapbase_ = uint64_t{0u};
}
inline uint64_t LibraryInfoPacket::_internal_mapbase() const {
  return mapbase_;
}
inline uint64_t LibraryInfoPacket::mapbase() const {
  // @@protoc_insertion_point(field_get:LibraryInfoPacket.MapBase)
  return _internal_mapbase();
}
inline void LibraryInfoPacket::_internal_set_mapbase(uint64_t value) {
  
  mapbase_ = value;
}
inline void LibraryInfoPacket::set_mapbase(uint64_t value) {
  _internal_set_mapbase(value);
  // @@protoc_insertion_point(field_set:LibraryInfoPacket.MapBase)
}

// uint64 MapSize = 4;
inline void LibraryInfoPacket::clear_mapsize() {
  mapsize_ = uint64_t{0u};
}
inline uint64_t LibraryInfoPacket::_internal_mapsize() const {
  return mapsize_;
}
inline uint64_t LibraryInfoPacket::mapsize() const {
  // @@protoc_insertion_point(field_get:LibraryInfoPacket.MapSize)
  return _internal_mapsize();
}
inline void LibraryInfoPacket::_internal_set_mapsize(uint64_t value) {
  
  mapsize_ = value;
}
inline void LibraryInfoPacket::set_mapsize(uint64_t value) {
  _internal_set_mapsize(value);
  // @@protoc_insertion_point(field_set:LibraryInfoPacket.MapSize)
}

// uint64 TextSize = 5;
inline void LibraryInfoPacket::clear_textsize() {
  textsize_ = uint64_t{0u};
}
inline uint64_t LibraryInfoPacket::_internal_textsize() const {
  return textsize_;
}
inline uint64_t LibraryInfoPacket::textsize() const {
  // @@protoc_insertion_point(field_get:LibraryInfoPacket.TextSize)
  return _internal_textsize();
}
inline void LibraryInfoPacket::_internal_set_textsize(uint64_t value) {
  
  textsize_ = value;
}
inline void LibraryInfoPacket::set_textsize(uint64_t value) {
  _internal_set_textsize(value);
  // @@protoc_insertion_point(field_set:LibraryInfoPacket.TextSize)
}

// uint64 DataBase = 6;
inline void LibraryInfoPacket::clear_database() {
  database_ = uint64_t{0u};
}
inline uint64_t LibraryInfoPacket::_internal_database() const {
  return database_;
}
inline uint64_t LibraryInfoPacket::database() const {
  // @@protoc_insertion_point(field_get:LibraryInfoPacket.DataBase)
  return _internal_database();
}
inline void LibraryInfoPacket::_internal_set_database(uint64_t value) {
  
  database_ = value;
}
inline void LibraryInfoPacket::set_database(uint64_t value) {
  _internal_set_database(value);
  // @@protoc_insertion_point(field_set:LibraryInfoPacket.DataBase)
}

// uint64 DataSize = 7;
inline void LibraryInfoPacket::clear_datasize() {
  datasize_ = uint64_t{0u};
}
inline uint64_t LibraryInfoPacket::_internal_datasize() const {
  return datasize_;
}
inline uint64_t LibraryInfoPacket::datasize() const {
  // @@protoc_insertion_point(field_get:LibraryInfoPacket.DataSize)
  return _internal_datasize();
}
inline void LibraryInfoPacket::_internal_set_datasize(uint64_t value) {
  
  datasize_ = value;
}
inline void LibraryInfoPacket::set_datasize(uint64_t value) {
  _internal_set_datasize(value);
  // @@protoc_insertion_point(field_set:LibraryInfoPacket.DataSize)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::APICommand> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::APICommand>() {
  return ::APICommand_descriptor();
}
template <> struct is_proto_enum< ::AppState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AppState>() {
  return ::AppState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_APIPackets_2eproto
